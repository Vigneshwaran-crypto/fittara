/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.0 src/Assets/3dFiles/swater.glb -o src/Component/Swater.jsx -r public 
*/

import React, { useCallback, useEffect, useRef, useState } from "react";
import { Decal, OrbitControls, useGLTF, useTexture } from "@react-three/drei";
import modelObj from "../Assets/3dFiles/swater.glb";
import userImg from "../Assets/auth/userProfile.png";
import { useControls } from "leva";
import { degToRad } from "three/src/math/MathUtils.js";
import { useDrag } from "@use-gesture/react";
import { useFrame, useLoader, useThree } from "@react-three/fiber";
import { Raycaster, TextureLoader, Vector2 } from "three";
import * as THREE from "three";

const Swater = (props) => {
  const { nodes, materials } = useGLTF(modelObj);
  const texture = useTexture(userImg);

  const clampTxture = useLoader(TextureLoader, userImg);
  const handRef = useRef();

  const raycaster = useRef(new Raycaster());
  const pointer = useRef(new Vector2());

  const { camera, gl } = useThree();

  const decal = useRef();
  const [position, setPosition] = useState([0, 0, 0]);
  const [rotation, setRotation] = useState([0, 0, 0]);
  const [scale, setScale] = useState([1.5, 1.5, 1.5]);

  const [isDragging, setDragging] = useState(false);

  // const [tempPos, setTempPos] = useState([1.2, 0, -0.2]);
  // const [tempRot, setTempRot] = useState([0, 1.7, 0]);

  const [tempPos, setTempPos] = useState([0, 0, 0]);
  const [tempRot, setTempRot] = useState([0, 0, 0]);

  const [isShiftPressed, setIsShiftPressed] = useState(false);

  const objectRef = useRef();

  // Dragging Logic
  const bind = useDrag(({ offset: [x, y], dragging }) => {
    setPosition([x * 0.01, -y * 0.01, position[2]]); // Adjust multiplier as needed
    setDragging(dragging);
  });

  useControls({
    angle: {
      min: -2,
      max: 2,
      // value: 1.8,
      value: position[0],
      step: 0.01,
      onChange: (val) => {
        // const x = Math.cos(val);
        const newPos = [val, position[1], position[2]];
        setPosition(newPos);
      },
    },
    posY: {
      min: -2,
      max: 2,
      // value: 1.8,
      value: position[1],
      step: 0.01,
      onChange: (val) => {
        const newPos = [position[0], val, position[2]];
        setPosition(newPos);
      },
    },
    scale: {
      min: 0.1,
      max: 2,
      value: 0.5,
      step: 0.01,
      onChange: (val) => {
        setScale(() => [val, val, 1.5]);
      },
    },

    x: {
      min: -2,
      max: 2,
      value: tempPos[0],
      step: 0.01,
      onChange: (val) => {
        console.log("x val :", val);

        // const vec = [val, tempPos[1], 0];

        // setTempPos(vec);
        setTempPos((prevPos) => [val, prevPos[1], prevPos[2]]);
      },
    },
    y: {
      min: -2,
      max: 2,
      value: tempPos[1],
      step: 0.01,
      onChange: (val) => {
        console.log("y val :", val);
        // const vect = [tempPos[0], val, 0];
        // setTempPos(vect);

        setTempPos((prevPos) => [prevPos[0], val, prevPos[2]]);
      },
    },
  });

  // const onHandClick = (e) => {
  //   e.stopPropagation();

  //   // Update pointer coordinates
  //   pointer.current.set(
  //     (e.clientX / gl.domElement.clientWidth) * 2 - 1,
  //     -(e.clientY / gl.domElement.clientHeight) * 2 + 1
  //   );

  //   // Set the raycaster from the camera and pointer
  //   raycaster.current.setFromCamera(pointer.current, camera);

  //   // Perform intersection with the mesh
  //   const intersects = raycaster.current.intersectObject(handRef.current, true);

  //   console.log("Intersects Array:", intersects); // Should log intersection data

  //   if (intersects.length > 0) {
  //     const intersect = intersects[0];
  //     const clickedPosition = intersect.point;

  //     console.log("Clicked Position on handRef:", clickedPosition);
  //     // Use clickedPosition for your logic
  //   } else {
  //     console.log("No intersection detected!");
  //   }
  // };

  // const onHandClick = (event) => {
  //   const pointer = new Vector2();
  //   pointer.set(
  //     (event.clientX / gl.domElement.clientWidth) * 2 - 1,
  //     -(event.clientY / gl.domElement.clientHeight) * 2 + 1
  //   );

  //   // Create a raycaster and update it
  //   const raycaster = new Raycaster();
  //   raycaster.setFromCamera(pointer, camera);

  //   // console.log("Clicked Position:", raycaster);

  //   const meshX = raycaster.ray.origin.x;
  //   const meshY = raycaster.ray.origin.y;
  //   const meshZ = raycaster.ray.origin.z;

  //   console.log("mesh clicked Pos : ", { meshX, meshY, meshZ });

  //   // position={[1.2, 0, -0.2]}
  //   // rotation={[0, 1.7, 0]}

  //   const flX = parseFloat(meshX.toFixed(1));
  //   const flY = parseFloat(meshY.toFixed(1));
  //   const flZ = parseFloat(meshZ.toFixed(1));

  //   console.log("mesh clicked Pos : ", { flX, flY, flZ });

  //   setTempPos([flX, 0, -0.2]);
  //   setTempRot([0, flX, 0]);

  //   // Check for intersections
  //   const intersects = raycaster.intersectObject(handRef.current);

  //   // console.log("Clicked intersects:", intersects);

  //   if (intersects.length > 0) {
  //     const clickedPosition = intersects[0].point; // The exact position on the mesh
  //     console.log("Clicked Position:", clickedPosition);

  //     // Execute any passed click handler
  //     // if (onClick) onClick(clickedPosition);
  //   }
  // };

  // const onHandClick = (event) => {
  //   console.log("onHandClick point :", event.point);

  //   const pointer = new Vector2();
  //   pointer.set(
  //     (event.clientX / gl.domElement.clientWidth) * 2 - 1,
  //     -(event.clientY / gl.domElement.clientHeight) * 2 + 1
  //   );

  //   // Create a raycaster and update it
  //   const raycaster = new Raycaster();
  //   raycaster.setFromCamera(pointer, camera);

  //   // Check for intersections
  //   const intersects = raycaster.intersectObject(handRef.current);

  //   console.log("handRef.current:", handRef.current);

  //   if (intersects.length > 0) {
  //     const clickedPosition = intersects[0].point; // The exact position on the mesh

  //     // Logging for debugging
  //     console.log("Clicked Position:", clickedPosition);

  //     // Round the coordinates to one decimal place
  //     const flX = parseFloat(clickedPosition.x.toFixed(1));
  //     const flY = parseFloat(clickedPosition.y.toFixed(1));
  //     const flZ = parseFloat(clickedPosition.z.toFixed(1));

  //     console.log("Rounded Position:", { flX, flY, flZ });

  //     // Set the temporary position and rotation
  //     setTempPos([flX, flY, flZ]);
  //     setTempRot([0, flX, 0]);
  //   } else {
  //     console.log("No intersection detected!");
  //   }
  // };

  // const onHandClick = (e) => {
  //   const clickedPosition = e.point;

  //   let vector = new THREE.Vector3();
  //   e.object.getWorldPosition(vector);
  //   console.log("clickedPosition vector", vector);

  //   // Round the coordinates to one decimal place
  //   const flX = parseFloat(clickedPosition.x.toFixed(1));
  //   const flY = parseFloat(clickedPosition.y.toFixed(1));
  //   const flZ = parseFloat(clickedPosition.z.toFixed(1));

  //   console.log("Rounded Position:", { flX, flY, flZ });

  //   //   // position={[1.2, 0, -0.2]}
  //   //   // rotation={[0, 1.7, 0]}

  //   // Set the temporary position and rotation
  //   setTempPos([flX, flY, flZ]);
  //   setTempRot([0, flX, 0]);
  // };

  const onHandClick = useCallback(
    (event) => {
      // Convert mouse position to normalized device coordinates
      const mouse = new Vector2();
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      // Create a raycaster
      const raycaster = new Raycaster();
      raycaster.setFromCamera(mouse, camera);

      // Perform the raycast
      const intersects = raycaster.intersectObject(handRef.current);

      if (intersects.length > 0) {
        // Get the intersection point in world coordinates
        const point = intersects[0].point;
        // setClickPoint(point);
        console.log("Clicked point:", point);
      }
    },
    [camera]
  );

  // Add the click event listener
  useFrame(() => {
    // if (decal.current) {
    //   decal.current.position.copy(camera.position);
    // }
    // console.log("Camera position byrames :", camera.position);
    // setTempPos([0.1, 0.3 - camera.position.y, 0]);
    // gl.domElement.addEventListener("click", onHandClick);
    // return () => {
    //   gl.domElement.removeEventListener("click", onHandClick);
    // };
    // console.log("cameraX", camera.position);
    // console.log("cameraX", camera.position.y);
    // console.log("cameraX", camera.position.z);
    // const actPos = [camera.position.x, -camera.position.y, camera.position.z];
    // setTempPos(actPos);
    // setTempRot([0, camera.position.x, 0]);
  });

  // worked as expected
  // useFrame(() => {
  //   const objectPosition = new THREE.Vector3(0, 0, 0); // Replace with your 3D object's position

  //   const cameraPosition = camera.position.clone();

  //   // Calculate the direction from the camera to the object
  //   const direction = new THREE.Vector3()
  //     .subVectors(objectPosition, cameraPosition)
  //     .normalize();

  //   // Set the position of tempPos to the current camera position
  //   setTempPos([camera.position.x, camera.position.y, camera.position.z]);

  //   // Use lookAt to rotate the camera to point towards the object
  //   camera.lookAt(objectPosition);

  //   // Calculate the rotation required to point the object
  //   const quaternion = camera.quaternion.clone();
  //   const euler = new THREE.Euler().setFromQuaternion(quaternion, "XYZ");

  //   // Set the rotation
  //   setTempRot([euler.x, euler.y, euler.z]);
  // });

  // const onMeshClick = (event) => {
  //   event.stopPropagation();

  //   //     mouseX = ( ( event.clientX - canvas.offsetLeft ) / canvas.clientWidth ) * 2 - 1;
  //   // mouseY = - ( ( event.clientY - canvas.offsetTop ) / canvas.clientHeight ) * 2 + 1;

  //   const raycaster = new Raycaster();
  //   const mouse = new Vector2();

  //   // Convert to normalized device coordinates (NDC)
  //   mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  //   mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

  //   raycaster.setFromCamera(mouse, camera);

  //   // Debugging - ensure mesh exists
  //   console.log("Mesh ref: ", handRef.current);

  //   if (!handRef.current) return;

  //   // Force geometry to calculate bounding box if necessary
  //   if (!handRef.current.geometry.boundingBox) {
  //     handRef.current.geometry.computeBoundingBox();
  //   }

  //   // Get intersections
  //   const intersects = raycaster.intersectObject(handRef.current, true); // 'true' to check all child meshes
  //   console.log("intersects :", intersects); // Check if intersects have values

  //   if (intersects.length > 0) {
  //     const intersect = intersects[0];
  //     const intersectPoint = intersect.point;
  //     const intersectNormal = intersect.face.normal;

  //     setTempPos(intersectPoint);
  //     setTempRot(new THREE.Euler().setFromVector3(intersectNormal));
  //   }
  // };

  const onMeshClick = (event) => {
    event.stopPropagation();

    const vec = new THREE.Vector3();
    const pos = new THREE.Vector3();

    // Convert to NDC (normalized device coordinates)
    vec.set(
      (event.clientX / window.innerWidth) * 2 - 1,
      -(event.clientY / window.innerHeight) * 2 + 1,
      0.5 // Z should be slightly in front of the camera
    );

    // Unproject from camera space to world space
    vec.unproject(camera);

    // Create a direction vector from the camera to the click position
    vec.sub(camera.position).normalize();

    // Calculate distance to intersect with the target object
    const distance = (handRef.current.position.z - camera.position.z) / vec.z;

    // Calculate the world position of the intersection
    pos.copy(camera.position).add(vec.multiplyScalar(distance));

    console.log("Calculated World Position:", pos);

    // Now, we can place the decal at this position
    // setTempPos(pos); // This will set the decal position

    let vector = new THREE.Vector3();
    vector.set(
      (event.clientX / window.innerWidth) * 2 - 1,
      -(event.clientY / window.innerHeight) * 2 + 1,
      0
    );
    vector.unproject(camera);

    console.log("actual vector :", vector);
    setTempPos(vector); // This will set the decal position

    // Optionally use raycasting here to ensure it's exactly on the mesh surface
  };

  const handBind = useDrag(({ offset: [x, y], dragging }) => {
    let vector = new THREE.Vector3();
    vector.set(
      (x / window.innerWidth) * 2 - 1,
      -(y / window.innerHeight) * 2 + 1,
      0
    );
    vector.unproject(camera);

    console.log("actual vector :", vector);
    setTempPos(vector);
    setTempRot([0, vector.z, 0]);
  });

  return (
    <group {...props} dispose={null} position={[0, 0, 0]}>
      <group rotation={[-Math.PI / 2, 0, 0]} scale={1.468} position={[0, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group scale={0.394}>
            <mesh
              geometry={nodes.g_Hoodie_Hoodie_0_1.geometry}
              material={materials.Hoodie}
            />
            <mesh
              geometry={nodes.g_Hoodie_Hoodie_0_2.geometry}
              material={materials.poacket}
            />
            <mesh
              geometry={nodes.g_Hoodie_Hoodie_0_3.geometry}
              // material={materials.front}
            >
              {/* <meshBasicMaterial color={"green"} map={texture} /> */}

              <Decal
                // debug
                ref={decal}
                position={position}
                rotation={rotation}
                scale={scale}
                {...bind()}
              >
                <meshBasicMaterial
                  map={texture}
                  polygonOffset
                  polygonOffsetFactor={-2} //the mesh should take procedence on orginal
                />
              </Decal>
            </mesh>
            <mesh
              geometry={nodes.g_Hoodie_Hoodie_0_4.geometry}
              material={materials.cape}
            />
            <mesh
              geometry={nodes.g_Hoodie_Hoodie_0_5.geometry}
              material={materials.back}
            />
            <mesh
              ref={handRef}
              geometry={nodes.g_Hoodie_Hoodie_0_6.geometry}
              // material={materials.left}
              // onClick={onMeshClick}
              // onPointerOver={() => console.log("pointer over here")}
              // position={[0, 0, 0]}
              // {...handBind()}
            >
              <Decal
                debug
                ref={decal}
                // position={position}
                // rotation={rotation}
                // scale={scale}
                // position={[1.2, 0, -0.2]}
                // rotation={[0, 1.7, 0]}
                position={tempPos}
                rotation={tempRot}
                // position={[0, 0, 0.4]}
                // rotation={[0, 0, 0]}
                scale={scale}
                // {...bind()}
              >
                <meshBasicMaterial
                  map={texture}
                  polygonOffset
                  polygonOffsetFactor={-2}
                />
              </Decal>
            </mesh>
            <mesh
              geometry={nodes.g_Hoodie_Hoodie_0_7.geometry}
              material={materials.lcuff}
            />
            <mesh
              geometry={nodes.g_Hoodie_Hoodie_0_8.geometry}
              material={materials.right}
            />
            <mesh
              geometry={nodes.g_Hoodie_Hoodie_0_9.geometry}
              material={materials.rcuff}
            />
          </group>
        </group>
      </group>

      <OrbitControls
        args={[camera, gl.domElement]}
        // maxDistance={2}
        // minDistance={1}
        enabled={!isDragging}
        enablePan={true}
        enableZoom={true}
      />
    </group>
  );
};

useGLTF.preload("/../src/Assets/3dFiles/swater.glb");

export default Swater;

// const handBind = useDrag(({ offset: [x, y], dragging }) => {
//   let vector = new THREE.Vector3();
//   vector.set(
//     (x / window.innerWidth) * 2 - 1,
//     -(y / window.innerHeight) * 2 + 1,
//     0
//   );
//   vector.unproject(camera);

//   console.log("actual vector :", vector);
//   setTempPos(vector);
// });

// worked as expected
// useFrame(() => {
//   const objectPosition = new THREE.Vector3(0, 0, 0); // Replace with your 3D object's position

//   const cameraPosition = camera.position.clone();

//   // Calculate the direction from the camera to the object
//   const direction = new THREE.Vector3()
//     .subVectors(objectPosition, cameraPosition)
//     .normalize();

//   // Set the position of tempPos to the current camera position
//   setTempPos([camera.position.x, camera.position.y, camera.position.z]);

//   // Use lookAt to rotate the camera to point towards the object
//   camera.lookAt(objectPosition);

//   // Calculate the rotation required to point the object
//   const quaternion = camera.quaternion.clone();
//   const euler = new THREE.Euler().setFromQuaternion(quaternion, "XYZ");

//   // Set the rotation
//   setTempRot([euler.x, euler.y, euler.z]);
// });
